const { Telegraf, Markup } = require('telegraf');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = parseInt(process.env.ADMIN_ID);
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const WEBHOOK_URL = process.env.WEBHOOK_URL;
const PORT = process.env.PORT || 3000;

const bot = new Telegraf(BOT_TOKEN);

// File paths
const plansFilePath = path.join(__dirname, 'plans.json');       // All diamond-related plans/packages
const ordersFilePath = path.join(__dirname, 'orders.json');
// Note: packages.json is not explicitly loaded here as per your request,
//       it's kept separate for future potential use.

// Load plans
let allProducts = {}; // To store all plans
try {
    allProducts = JSON.parse(fs.readFileSync(plansFilePath, 'utf8'));
} catch (error) {
    console.error('Error loading plans.json:', error);
    allProducts = {}; // Fallback to empty object if file is not found or invalid
}

// Ensure orders.json exists
if (!fs.existsSync(ordersFilePath)) {
    fs.writeFileSync(ordersFilePath, JSON.stringify([]), 'utf8');
}

// Temporary storage for user input (for multi-step processes)
const userSessions = {}; // { userId: { step: 'waiting_for_uid' | 'waiting_for_payment_details', productCode: 'FX1', uid: '...', transactionId: '...', screenshotId: '...' } }

// --- Helper Functions ---

function getPlansList() { // Renamed from getPackagesList for clarity
    let message = "‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶°‡¶æ‡¶Ø‡¶º‡¶Æ‡¶®‡ßç‡¶° ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶®‡¶ø‡¶ö‡ßá ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶≤‡ßã:\n\n";
    for (const category in allProducts) { // Iterate through all plans
        message += `‚≠ê ${category} üì¶\n`;
        allProducts[category].forEach(product => {
            message += `‚Ä¢ ${product.code} - ${product.name} = ${product.price}‡ß≥\n`;
        });
        message += "\n";
    }
    message += "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡¶õ‡¶®‡ßç‡¶¶‡ßá‡¶∞ ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶∞ ‡¶ï‡ßã‡¶° ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§";
    return message;
}

function saveOrder(order) {
    const orders = JSON.parse(fs.readFileSync(ordersFilePath, 'utf8'));
    orders.push(order);
    fs.writeFileSync(ordersFilePath, JSON.stringify(orders, null, 2), 'utf8');
}

// --- Bot Commands and Actions ---

bot.start(async (ctx) => {
    await ctx.reply(
        `‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ, ${ctx.from.first_name}!\n\n` +
        `‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Fire ‡¶Ü‡¶á‡¶°‡¶ø-‡¶§‡ßá ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤‡¶ø ‡¶°‡¶æ‡¶Ø‡¶º‡¶Æ‡¶®‡ßç‡¶° ‡¶ü‡¶™-‡¶Ü‡¶™ ‡¶ï‡¶∞‡ßá ‡¶•‡¶æ‡¶ï‡¶ø‡•§\n\n` +
        `‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ‡¶æ‡¶¨‡¶≤‡ßÄ:\n` +
        `‡ßß. "Buy Now" ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶® ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®‡•§\n` +
        `‡ß®. ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡¶õ‡¶®‡ßç‡¶¶‡ßá‡¶∞ ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶® ‡¶ï‡ßã‡¶° ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§\n` +
        `‡ß©. ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Fire UID ‡¶¶‡¶ø‡¶®‡•§\n` +
        `‡ß™. ‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶ï‡¶∞‡ßá ‡¶ü‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶∏‡ßá‡¶ï‡¶∂‡¶® ‡¶Ü‡¶á‡¶°‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶¶‡¶ø‡¶®‡•§\n` +
        `‡ß´. ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶™‡¶∞ ‡¶°‡¶æ‡¶Ø‡¶º‡¶Æ‡¶®‡ßç‡¶° ‡¶™‡¶æ‡¶†‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶¨‡ßá‡•§\n\n` +
        `‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶•‡¶æ‡¶ï‡¶≤‡ßá \`/ask ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®\` ‡¶≤‡¶ø‡¶ñ‡ßá ‡¶ú‡¶ø‡¶ú‡ßç‡¶û‡¶æ‡¶∏‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®‡•§`,
        Markup.inlineKeyboard([
            Markup.button.callback('Buy Now', 'buy_now')
        ])
    );
});

bot.action('buy_now', async (ctx) => {
    await ctx.editMessageText(getPlansList()); // Changed to getPlansList
});

// Handling plan code input
bot.on('text', async (ctx) => {
    const userId = ctx.from.id;
    const text = ctx.message.text;

    // Handle /ask command
    if (text.startsWith('/ask ')) {
        const question = text.substring(5).trim();
        if (question) {
            try {
                const response = await axios.post('https://api.openai.com/v1/chat/completions', {
                    model: "gpt-3.5-turbo",
                    messages: [{ role: "user", content: question }],
                    max_tokens: 150,
                    n: 1,
                    stop: null,
                    temperature: 0.7,
                }, {
                    headers: {
                        'Authorization': `Bearer ${OPENAI_API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });
                const aiAnswer = response.data.choices[0].message.content.trim();
                await ctx.reply(`‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞:\n\n${aiAnswer}`);
            } catch (error) {
                console.error('Error with OpenAI API:', error.response ? error.response.data : error.message);
                await ctx.reply('‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡¶®‡¶ø‡•§');
            }
        } else {
            await ctx.reply('‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡¶ü‡¶ø `/ask` ‡¶è‡¶∞ ‡¶™‡¶∞ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§');
        }
        return; // Exit after handling /ask
    }

    // Check if user is in a multi-step process
    if (userSessions[userId]) {
        if (userSessions[userId].step === 'waiting_for_uid') {
            userSessions[userId].uid = text;
            userSessions[userId].step = 'waiting_for_payment_details';

            await ctx.reply(
                `‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Fire UID: ${text}\n\n` +
                `‡¶è‡¶¨‡¶æ‡¶∞ ‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®:\n\n` +
                `üí∞ bKash: 01965064030\n` +
                `üí∞ Nagad: 01937240300\n\n` +
                `‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞ ‡¶ü‡ßç‡¶∞‡¶æ‡¶®‡¶ú‡ßá‡¶ï‡¶∂‡¶® ‡¶Ü‡¶á‡¶°‡¶ø (Transaction ID) ‡¶è‡¶¨‡¶Ç ‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶Ü‡¶Æ‡¶æ‡¶ï‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶ü‡ßç‡¶∞‡¶æ‡¶®‡¶ú‡ßá‡¶ï‡¶∂‡¶® ‡¶Ü‡¶á‡¶°‡¶ø ‡¶¶‡¶ø‡¶®, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§`
            );
        } else if (userSessions[userId].step === 'waiting_for_payment_details') {
            userSessions[userId].transactionId = text;
            userSessions[userId].step = 'waiting_for_screenshot';
            await ctx.reply('‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶! ‡¶è‡¶¨‡¶æ‡¶∞ ‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü‡¶ü‡¶ø ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§');
        }
        return; // Exit after handling session steps
    }

    // Check if the text is a valid product code (from plans)
    let selectedProduct = null;
    for (const category in allProducts) { // Search only in allProducts (loaded from plans.json)
        selectedProduct = allProducts[category].find(product => product.code.toUpperCase() === text.toUpperCase());
        if (selectedProduct) break;
    }

    if (selectedProduct) {
        userSessions[userId] = {
            step: 'waiting_for_uid',
            productCode: selectedProduct.code,
            productName: selectedProduct.name,
            productPrice: selectedProduct.price,
            timestamp: new Date().toISOString()
        };
        await ctx.reply(`‡¶Ü‡¶™‡¶®‡¶ø "${selectedProduct.name}" (${selectedProduct.price}‡ß≥) ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶®‡•§\n\n‡¶è‡¶¨‡¶æ‡¶∞ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Fire Player ID (UID) ‡¶¶‡¶ø‡¶®:`);
    } else {
        await ctx.reply('‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶Ü‡¶™‡¶®‡¶ø ‡¶≠‡ßÅ‡¶≤ ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶® ‡¶ï‡ßã‡¶° ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶á‡¶®‡¶™‡ßÅ‡¶ü‡¶ü‡¶ø ‡¶¨‡ßã‡¶ù‡¶æ ‡¶Ø‡¶æ‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶∏‡¶†‡¶ø‡¶ï ‡¶ï‡ßã‡¶° ‡¶¶‡¶ø‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ `/start` ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§');
    }
});

// Handling screenshot
bot.on('photo', async (ctx) => {
    const userId = ctx.from.id;
    if (userSessions[userId] && userSessions[userId].step === 'waiting_for_screenshot') {
        const fileId = ctx.message.photo[ctx.message.photo.length - 1].file_id;
        userSessions[userId].screenshotId = fileId;

        const { productCode, productName, productPrice, uid, transactionId, screenshotId, timestamp } = userSessions[userId];

        const order = {
            orderId: Date.now().toString(), // Simple unique ID
            userId: userId,
            userName: ctx.from.first_name + (ctx.from.last_name ? ' ' + ctx.from.last_name : ''),
            productCode,
            productName,
            productPrice,
            uid,
            transactionId,
            screenshotId,
            timestamp,
            status: 'Pending'
        };

        saveOrder(order);

        // Forward to admin
        const adminMessage = `
**‡¶®‡¶§‡ßÅ‡¶® ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞!**
---
**‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø:** ${order.orderId}
**‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø:** ${order.userId}
**‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶®‡¶æ‡¶Æ:** ${order.userName}
**‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶®:** ${order.productName} (${order.productCode})
**‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø:** ${order.productPrice}‡ß≥
**UID:** ${order.uid}
**‡¶ü‡ßç‡¶∞‡¶æ‡¶®‡¶ú‡ßá‡¶ï‡¶∂‡¶® ‡¶Ü‡¶á‡¶°‡¶ø:** ${order.transactionId}
**‡¶∏‡¶Æ‡¶Ø‡¶º:** ${new Date(order.timestamp).toLocaleString('bn-BD', { timeZone: 'Asia/Dhaka' })}
---
`;
        await bot.telegram.sendPhoto(ADMIN_ID, screenshotId, {
            caption: adminMessage,
            parse_mode: 'Markdown',
            reply_markup: Markup.inlineKeyboard([
                [Markup.button.callback('‚úÖ Approve', `approve_${order.orderId}`)],
                [Markup.button.callback('‚ùå Reject', `reject_${order.orderId}`)]
            ])
        });

        await ctx.reply('‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ó‡ßç‡¶∞‡¶π‡¶£ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá! ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡¶ü‡¶ø ‡¶∞‡¶ø‡¶≠‡¶ø‡¶â ‡¶ï‡¶∞‡ßá ‡¶ñ‡ßÅ‡¶¨ ‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶ú‡¶æ‡¶®‡¶æ‡¶¨‡ßá‡¶®‡•§');

        delete userSessions[userId]; // Clear session
    } else {
        await ctx.reply('‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶® ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶ó‡ßç‡¶∞‡¶π‡¶£ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§ ‡¶®‡¶á‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶ü‡¶ø ‡¶∏‡¶†‡¶ø‡¶ï ‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§');
    }
});

// Admin actions: Approve/Reject
bot.action(/approve_(.+)/, async (ctx) => {
    if (ctx.from.id !== ADMIN_ID) {
        return ctx.reply('‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶á ‡¶ï‡¶æ‡¶ú‡¶ü‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø‡¶™‡ßç‡¶∞‡¶æ‡¶™‡ßç‡¶§ ‡¶®‡¶®‡•§');
    }

    const orderId = ctx.match[1];
    let orders = JSON.parse(fs.readFileSync(ordersFilePath, 'utf8'));
    const orderIndex = orders.findIndex(o => o.orderId === orderId);

    if (orderIndex !== -1) {
        orders[orderIndex].status = 'Approved';
        fs.writeFileSync(ordersFilePath, JSON.stringify(orders, null, 2), 'utf8');

        await ctx.editMessageReplyMarkup(Markup.inlineKeyboard([
            [Markup.button.callback('‚úÖ Approved', 'approved_dummy')]
        ])); // Update admin message to show status

        // Notify user
        await bot.telegram.sendMessage(orders[orderIndex].userId, `‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶! ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Fire Diamond ‡¶ü‡¶™-‡¶Ü‡¶™ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ (ID: ${orderId}) ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§`);
    } else {
        await ctx.reply('‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§');
    }
});

bot.action(/reject_(.+)/, async (ctx) => {
    if (ctx.from.id !== ADMIN_ID) {
        return ctx.reply('‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶á ‡¶ï‡¶æ‡¶ú‡¶ü‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø‡¶™‡ßç‡¶∞‡¶æ‡¶™‡ßç‡¶§ ‡¶®‡¶®‡•§');
    }

    const orderId = ctx.match[1];
    let orders = JSON.parse(fs.readFileSync(ordersFilePath, 'utf8'));
    const orderIndex = orders.findIndex(o => o.orderId === orderId);

    if (orderIndex !== -1) {
        orders[orderIndex].status = 'Rejected';
        fs.writeFileSync(ordersFilePath, JSON.stringify(orders, null, 2), 'utf8');

        await ctx.editMessageReplyMarkup(Markup.inlineKeyboard([
            [Markup.button.callback('‚ùå Rejected', 'rejected_dummy')]
        ])); // Update admin message to show status

        // Notify user
        await bot.telegram.sendMessage(orders[orderIndex].userId, `‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§! ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Fire Diamond ‡¶ü‡¶™-‡¶Ü‡¶™ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ (ID: ${orderId}) ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶≤‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®‡•§`);
    } else {
        await ctx.reply('‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§');
    }
});

// Set up webhook for Render deployment
if (process.env.NODE_ENV === 'production') {
    bot.launch({
        webhook: {
            domain: WEBHOOK_URL.replace('https://', ''),
            port: PORT
        }
    }).then(() => {
        console.log(`Bot running in production mode via webhook on port ${PORT}`);
    }).catch(err => {
        console.error('Failed to launch webhook:', err);
    });
} else {
    bot.launch().then(() => {
        console.log('Bot running in development mode (polling)');
    }).catch(err => {
        console.error('Failed to launch polling:', err);
    });
}

// Enable graceful stop
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
